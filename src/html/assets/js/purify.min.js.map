{
version: 3,
file: "purify.min.js",
sources: [
"../src/utils.js",
"../src/purify.js",
"../src/tags.js",
"../src/attrs.js",
"../src/regexp.js"
],
sourcesContent: [
"/* Add properties to a lookup table */ export function addToSet(set, array) { let l = array.length; while (l--) { if (typeof array[l] === 'string') { array[l] = array[l].toLowerCase(); } set[array[l]] = true; } return set; } /* Shallow clone an object */ export function clone(object) { const newObject = {}; let property; for (property in object) { if (Object.prototype.hasOwnProperty.call(object, property)) { newObject[property] = object[property]; } } return newObject; } ",
"import * as TAGS from './tags'; import * as ATTRS from './attrs'; import { addToSet, clone } from './utils'; import * as EXPRESSIONS from './regexp'; const getGlobal = () => (typeof window === 'undefined' ? null : window); function createDOMPurify(window = getGlobal()) { const DOMPurify = root => createDOMPurify(root); /** * Version label, exposed for easier checks * if DOMPurify is up to date or not */ DOMPurify.version = VERSION; /** * Array of elements that DOMPurify removed during sanitation. * Empty if nothing was removed. */ DOMPurify.removed = []; if (!window || !window.document || window.document.nodeType !== 9) { // Not running in a browser, provide a factory function // so that you can pass your own Window DOMPurify.isSupported = false; return DOMPurify; } const originalDocument = window.document; let useDOMParser = false; // See comment below let useXHR = false; let document = window.document; const { DocumentFragment, HTMLTemplateElement, Node, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, Text, Comment, DOMParser, XMLHttpRequest = window.XMLHttpRequest, encodeURI = window.encodeURI, } = window; // As per issue #47, the web-components registry is inherited by a // new document created via createHTMLDocument. As per the spec // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries) // a new empty registry is used when creating a template contents owner // document, so we use that as our parent document to ensure nothing // is inherited. if (typeof HTMLTemplateElement === 'function') { const template = document.createElement('template'); if (template.content && template.content.ownerDocument) { document = template.content.ownerDocument; } } const { implementation, createNodeIterator, getElementsByTagName, createDocumentFragment, } = document; const importNode = originalDocument.importNode; let hooks = {}; /** * Expose whether this browser supports running the full DOMPurify. */ DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9; const { MUSTACHE_EXPR, ERB_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, } = EXPRESSIONS; let IS_ALLOWED_URI = EXPRESSIONS.IS_ALLOWED_URI; /** * We consider the elements and attributes below to be safe. Ideally * don't add any new ones but feel free to remove unwanted ones. */ /* allowed element names */ let ALLOWED_TAGS = null; const DEFAULT_ALLOWED_TAGS = addToSet({}, [ ...TAGS.html, ...TAGS.svg, ...TAGS.svgFilters, ...TAGS.mathMl, ...TAGS.text, ]); /* Allowed attribute names */ let ALLOWED_ATTR = null; const DEFAULT_ALLOWED_ATTR = addToSet({}, [ ...ATTRS.html, ...ATTRS.svg, ...ATTRS.mathMl, ...ATTRS.xml, ]); /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null; /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null; /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true; /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true; /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false; /* Output should be safe for jQuery's $() factory? */ let SAFE_FOR_JQUERY = false; /* Output should be safe for common template engines. * This means, DOMPurify removes data attributes, mustaches and ERB */ let SAFE_FOR_TEMPLATES = false; /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false; /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false; /* Decide if all elements (e.g. style, script) must be children of * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false; /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string. * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead */ let RETURN_DOM = false; /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */ let RETURN_DOM_FRAGMENT = false; /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM * `Node` is imported into the current `Document`. If this flag is not enabled the * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by * DOMPurify. */ let RETURN_DOM_IMPORT = false; /* Output should be free from DOM clobbering attacks? */ let SANITIZE_DOM = true; /* Keep element content when removing element? */ let KEEP_CONTENT = true; /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {}; /* Tags to ignore content of when KEEP_CONTENT is true */ const FORBID_CONTENTS = addToSet({}, [ 'audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video', ]); /* Tags that are safe for data: URIs */ const DATA_URI_TAGS = addToSet({}, [ 'audio', 'video', 'img', 'source', 'image', ]); /* Attributes safe for values like "javascript:" */ const URI_SAFE_ATTRIBUTES = addToSet({}, [ 'alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns', ]); /* Keep a reference to config to pass to hooks */ let CONFIG = null; /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement('form'); /** * _parseConfig * * @param optional config literal */ // eslint-disable-next-line complexity const _parseConfig = function(cfg) { /* Shield configuration object from tampering */ if (typeof cfg !== 'object') { cfg = {}; } /* Set configuration parameters */ ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS; ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR; FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {}; FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {}; USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false; ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false RETURN_DOM = cfg.RETURN_DOM || false; // Default false RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false FORCE_BODY = cfg.FORCE_BODY || false; // Default false SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI; if (SAFE_FOR_TEMPLATES) { ALLOW_DATA_ATTR = false; } if (RETURN_DOM_FRAGMENT) { RETURN_DOM = true; } /* Parse profile info */ if (USE_PROFILES) { ALLOWED_TAGS = addToSet({}, [...TAGS.text]); ALLOWED_ATTR = []; if (USE_PROFILES.html === true) { addToSet(ALLOWED_TAGS, TAGS.html); addToSet(ALLOWED_ATTR, ATTRS.html); } if (USE_PROFILES.svg === true) { addToSet(ALLOWED_TAGS, TAGS.svg); addToSet(ALLOWED_ATTR, ATTRS.svg); addToSet(ALLOWED_ATTR, ATTRS.xml); } if (USE_PROFILES.svgFilters === true) { addToSet(ALLOWED_TAGS, TAGS.svgFilters); addToSet(ALLOWED_ATTR, ATTRS.svg); addToSet(ALLOWED_ATTR, ATTRS.xml); } if (USE_PROFILES.mathMl === true) { addToSet(ALLOWED_TAGS, TAGS.mathMl); addToSet(ALLOWED_ATTR, ATTRS.mathMl); addToSet(ALLOWED_ATTR, ATTRS.xml); } } /* Merge configuration parameters */ if (cfg.ADD_TAGS) { if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) { ALLOWED_TAGS = clone(ALLOWED_TAGS); } addToSet(ALLOWED_TAGS, cfg.ADD_TAGS); } if (cfg.ADD_ATTR) { if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) { ALLOWED_ATTR = clone(ALLOWED_ATTR); } addToSet(ALLOWED_ATTR, cfg.ADD_ATTR); } if (cfg.ADD_URI_SAFE_ATTR) { addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR); } /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) { ALLOWED_TAGS['#text'] = true; } // Prevent further manipulation of configuration. // Not available in IE8, Safari 5, etc. if (Object && 'freeze' in Object) { Object.freeze(cfg); } CONFIG = cfg; }; /** * _forceRemove * * @param a DOM node */ const _forceRemove = function(node) { DOMPurify.removed.push({ element: node }); try { node.parentNode.removeChild(node); } catch (err) { node.outerHTML = ''; } }; /** * _removeAttribute * * @param an Attribute name * @param a DOM node */ const _removeAttribute = function(name, node) { try { DOMPurify.removed.push({ attribute: node.getAttributeNode(name), from: node, }); } catch (err) { DOMPurify.removed.push({ attribute: null, from: node, }); } node.removeAttribute(name); }; /** * _initDocument * * @param a string of dirty markup * @return a DOM, filled with the dirty markup */ const _initDocument = function(dirty) { /* Create a HTML document */ let doc; let body; if (FORCE_BODY) { dirty = '<remove></remove>' + dirty; } /* Use XHR if necessary because Safari 10.1 and newer are buggy */ if (useXHR) { try { dirty = encodeURI(dirty); } catch (err) {} const xhr = new XMLHttpRequest(); xhr.responseType = 'document'; xhr.open('GET', 'data:text/html;charset=utf-8,' + dirty, false); xhr.send(null); doc = xhr.response; } /* Use DOMParser to workaround Firefox bug (see comment below) */ if (useDOMParser) { try { doc = new DOMParser().parseFromString(dirty, 'text/html'); } catch (err) {} } /* Otherwise use createHTMLDocument, because DOMParser is unsafe in Safari (see comment below) */ if (!doc || !doc.documentElement) { doc = implementation.createHTMLDocument(''); body = doc.body; body.parentNode.removeChild(body.parentNode.firstElementChild); body.outerHTML = dirty; } /* Work on whole document or just its body */ return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0]; }; // Safari 10.1+ (unfixed as of time of writing) has a catastrophic bug in // its implementation of DOMParser such that the following executes the // JavaScript: // // new DOMParser() // .parseFromString('<svg onload=alert(document.domain)>', 'text/html'); // // Later, it was also noticed that even more assumed benign and inert ways // of creating a document are now insecure thanks to Safari. So we work // around that with a feature test and use XHR to create the document in // case we really have to. That one seems safe for now. // // However, Firefox uses a different parser for innerHTML rather than // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631) // which means that you *must* use DOMParser, otherwise the output may // not be safe if used in a document.write context later. // // So we feature detect the Firefox bug and use the DOMParser if necessary. if (DOMPurify.isSupported) { (function() { let doc = _initDocument( '<svg><g onload="this.parentNode.remove()"></g></svg>' ); if (!doc.querySelector('svg')) { useXHR = true; } try { doc = _initDocument( '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">' ); if (doc.querySelector('svg img')) { useDOMParser = true; } } catch (err) {} })(); } /** * _createIterator * * @param document/fragment to create iterator for * @return iterator instance */ const _createIterator = function(root) { return createNodeIterator.call( root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, () => { return NodeFilter.FILTER_ACCEPT; }, false ); }; /** * _isClobbered * * @param element to check for clobbering attacks * @return true if clobbered, false if safe */ const _isClobbered = function(elm) { if (elm instanceof Text || elm instanceof Comment) { return false; } if ( typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' ) { return true; } return false; }; /** * _isNode * * @param object to check whether it's a DOM node * @return true is object is a DOM node */ const _isNode = function(obj) { return typeof Node === 'object' ? obj instanceof Node : obj && typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string'; }; /** * _executeHook * Execute user configurable hooks * * @param {String} entryPoint Name of the hook's entry point * @param {Node} currentNode */ const _executeHook = function(entryPoint, currentNode, data) { if (!hooks[entryPoint]) { return; } hooks[entryPoint].forEach(hook => { hook.call(DOMPurify, currentNode, data, CONFIG); }); }; /** * _sanitizeElements * * @protect nodeName * @protect textContent * @protect removeChild * * @param node to check for permission to exist * @return true if node was killed, false if left alive */ const _sanitizeElements = function(currentNode) { let content; /* Execute a hook if present */ _executeHook('beforeSanitizeElements', currentNode, null); /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) { _forceRemove(currentNode); return true; } /* Now let's check the element's type and name */ const tagName = currentNode.nodeName.toLowerCase(); /* Execute a hook if present */ _executeHook('uponSanitizeElement', currentNode, { tagName, allowedTags: ALLOWED_TAGS, }); /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) { /* Keep content except for black-listed elements */ if ( KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function' ) { try { currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML); } catch (err) {} } _forceRemove(currentNode); return true; } /* Convert markup to cover jQuery behavior */ if ( SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent) ) { DOMPurify.removed.push({ element: currentNode.cloneNode() }); currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;'); } /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) { /* Get the element's text content */ content = currentNode.textContent; content = content.replace(MUSTACHE_EXPR, ' '); content = content.replace(ERB_EXPR, ' '); if (currentNode.textContent !== content) { DOMPurify.removed.push({ element: currentNode.cloneNode() }); currentNode.textContent = content; } } /* Execute a hook if present */ _executeHook('afterSanitizeElements', currentNode, null); return false; }; /** * _sanitizeAttributes * * @protect attributes * @protect nodeName * @protect removeAttribute * @protect setAttribute * * @param node to sanitize * @return void */ // eslint-disable-next-line complexity const _sanitizeAttributes = function(currentNode) { let attr; let name; let value; let lcName; let idAttr; let attributes; let l; /* Execute a hook if present */ _executeHook('beforeSanitizeAttributes', currentNode, null); attributes = currentNode.attributes; /* Check if we have attributes; if not we might have a text node */ if (!attributes) { return; } const hookEvent = { attrName: '', attrValue: '', keepAttr: true, allowedAttributes: ALLOWED_ATTR, }; l = attributes.length; /* Go backwards over all attributes; safely remove bad ones */ while (l--) { attr = attributes[l]; name = attr.name; value = attr.value.trim(); lcName = name.toLowerCase(); /* Execute a hook if present */ hookEvent.attrName = lcName; hookEvent.attrValue = value; hookEvent.keepAttr = true; _executeHook('uponSanitizeAttribute', currentNode, hookEvent); value = hookEvent.attrValue; /* Remove attribute */ // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to // remove a "name" attribute from an <img> tag that has an "id" // attribute at the time. if ( lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id ) { idAttr = attributes.id; attributes = Array.prototype.slice.apply(attributes); _removeAttribute('id', currentNode); _removeAttribute(name, currentNode); if (attributes.indexOf(idAttr) > l) { currentNode.setAttribute('id', idAttr.value); } } else if ( // This works around a bug in Safari, where input[type=file] // cannot be dynamically set after type has been removed currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName]) ) { continue; } else { // This avoids a crash in Safari v9.0 with double-ids. // The trick is to first set the id to be empty and then to // remove the attribute if (name === 'id') { currentNode.setAttribute(name, ''); } _removeAttribute(name, currentNode); } /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) { continue; } /* Make sure attribute cannot clobber */ if ( SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement) ) { continue; } /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) { value = value.replace(MUSTACHE_EXPR, ' '); value = value.replace(ERB_EXPR, ' '); } /* Allow valid data-* attributes: At least one character after "-" (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes) XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804) We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) { // This attribute is safe } else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) { // This attribute is safe /* Otherwise, check the name is permitted */ } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) { continue; /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) { // This attribute is safe /* Check no script, data or unknown possibly unsafe URI unless we know URI values are safe for that attribute */ } else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE, ''))) { // This attribute is safe /* Keep image data URIs alive if src/xlink:href is allowed */ } else if ( (lcName === 'src' || lcName === 'xlink:href') && value.indexOf('data:') === 0 && DATA_URI_TAGS[currentNode.nodeName.toLowerCase()] ) { // This attribute is safe /* Allow unknown protocols: This provides support for links that are handled by protocol handlers which may be unknown ahead of time, e.g. fb:, spotify: */ } else if ( ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE, '')) ) { // This attribute is safe /* Check for binary attributes */ // eslint-disable-next-line no-negated-condition } else if (!value) { // Binary attributes are safe at this point /* Anything else, presume unsafe, do not add it back */ } else { continue; } /* Handle invalid data-* attribute set by try-catching it */ try { currentNode.setAttribute(name, value); DOMPurify.removed.pop(); } catch (err) {} } /* Execute a hook if present */ _executeHook('afterSanitizeAttributes', currentNode, null); }; /** * _sanitizeShadowDOM * * @param fragment to iterate over recursively * @return void */ const _sanitizeShadowDOM = function(fragment) { let shadowNode; const shadowIterator = _createIterator(fragment); /* Execute a hook if present */ _executeHook('beforeSanitizeShadowDOM', fragment, null); while ((shadowNode = shadowIterator.nextNode())) { /* Execute a hook if present */ _executeHook('uponSanitizeShadowNode', shadowNode, null); /* Sanitize tags and elements */ if (_sanitizeElements(shadowNode)) { continue; } /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) { _sanitizeShadowDOM(shadowNode.content); } /* Check attributes, sanitize if necessary */ _sanitizeAttributes(shadowNode); } /* Execute a hook if present */ _executeHook('afterSanitizeShadowDOM', fragment, null); }; /** * Sanitize * Public method providing core sanitation functionality * * @param {String|Node} dirty string or DOM node * @param {Object} configuration object */ // eslint-disable-next-line complexity DOMPurify.sanitize = function(dirty, cfg) { let body; let importedNode; let currentNode; let oldNode; let returnNode; /* Make sure we have a string to sanitize. DO NOT return early, as this will return the wrong type if the user has requested a DOM object rather than a string */ if (!dirty) { dirty = '<!-->'; } /* Stringify, in case dirty is an object */ if (typeof dirty !== 'string' && !_isNode(dirty)) { // eslint-disable-next-line no-negated-condition if (typeof dirty.toString !== 'function') { throw new TypeError('toString is not a function'); } else { dirty = dirty.toString(); if (typeof dirty !== 'string') { throw new TypeError('dirty is not a string, aborting'); } } } /* Check we can run. Otherwise fall back or ignore */ if (!DOMPurify.isSupported) { if ( typeof window.toStaticHTML === 'object' || typeof window.toStaticHTML === 'function' ) { if (typeof dirty === 'string') { return window.toStaticHTML(dirty); } else if (_isNode(dirty)) { return window.toStaticHTML(dirty.outerHTML); } } return dirty; } /* Assign config vars */ if (!SET_CONFIG) { _parseConfig(cfg); } /* Clean up removed elements */ DOMPurify.removed = []; if (dirty instanceof Node) { /* If dirty is a DOM element, append to an empty document to avoid elements being stripped by the parser */ body = _initDocument('<!-->'); importedNode = body.ownerDocument.importNode(dirty, true); if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') { /* Node is already a body, use as is */ body = importedNode; } else { body.appendChild(importedNode); } } else { /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) { return dirty; } /* Initialize the document to work on */ body = _initDocument(dirty); /* Check we have a DOM node from the data */ if (!body) { return RETURN_DOM ? null : ''; } } /* Remove first element node (ours) if FORCE_BODY is set */ if (FORCE_BODY) { _forceRemove(body.firstChild); } /* Get node iterator */ const nodeIterator = _createIterator(body); /* Now start iterating over the created document */ while ((currentNode = nodeIterator.nextNode())) { /* Fix IE's strange behavior with manipulated textNodes #89 */ if (currentNode.nodeType === 3 && currentNode === oldNode) { continue; } /* Sanitize tags and elements */ if (_sanitizeElements(currentNode)) { continue; } /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) { _sanitizeShadowDOM(currentNode.content); } /* Check attributes, sanitize if necessary */ _sanitizeAttributes(currentNode); oldNode = currentNode; } /* Return sanitized string or DOM */ if (RETURN_DOM) { if (RETURN_DOM_FRAGMENT) { returnNode = createDocumentFragment.call(body.ownerDocument); while (body.firstChild) { returnNode.appendChild(body.firstChild); } } else { returnNode = body; } if (RETURN_DOM_IMPORT) { /* AdoptNode() is not used because internal state is not reset (e.g. the past names map of a HTMLFormElement), this is safe in theory but we would rather not risk another attack vector. The state that is cloned by importNode() is explicitly defined by the specs. */ returnNode = importNode.call(originalDocument, returnNode, true); } return returnNode; } return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML; }; /** * Public method to set the configuration once * setConfig * * @param {Object} configuration object * @return void */ DOMPurify.setConfig = function(cfg) { _parseConfig(cfg); SET_CONFIG = true; }; /** * Public method to remove the configuration * clearConfig * * @return void */ DOMPurify.clearConfig = function() { CONFIG = null; SET_CONFIG = false; }; /** * AddHook * Public method to add DOMPurify hooks * * @param {String} entryPoint * @param {Function} hookFunction */ DOMPurify.addHook = function(entryPoint, hookFunction) { if (typeof hookFunction !== 'function') { return; } hooks[entryPoint] = hooks[entryPoint] || []; hooks[entryPoint].push(hookFunction); }; /** * RemoveHook * Public method to remove a DOMPurify hook at a given entryPoint * (pops it from the stack of hooks if more are present) * * @param {String} entryPoint * @return void */ DOMPurify.removeHook = function(entryPoint) { if (hooks[entryPoint]) { hooks[entryPoint].pop(); } }; /** * RemoveHooks * Public method to remove all DOMPurify hooks at a given entryPoint * * @param {String} entryPoint * @return void */ DOMPurify.removeHooks = function(entryPoint) { if (hooks[entryPoint]) { hooks[entryPoint] = []; } }; /** * RemoveAllHooks * Public method to remove all DOMPurify hooks * * @return void */ DOMPurify.removeAllHooks = function() { hooks = {}; }; return DOMPurify; } export default createDOMPurify(); ",
"export const html = [ 'a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', ]; // SVG export const svg = [ 'svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', ]; export const svgFilters = [ 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', ]; export const mathMl = [ 'math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmuliscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mpspace', 'msqrt', 'mystyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', ]; export const text = ['#text']; ",
"export const html = [ 'accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', ]; export const svg = [ 'accent-height', 'accumulate', 'additivive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan', ]; export const mathMl = [ 'accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns', ]; export const xml = [ 'xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink', ]; ",
"export const MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm; // Specify template detection regex for SAFE_FOR_TEMPLATES mode export const ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm; export const DATA_ATTR = /^data-[\-\w.\u00B7-\uFFFF]/; // eslint-disable-line no-useless-escape export const ARIA_ATTR = /^aria-[\-\w]+$/; // eslint-disable-line no-useless-escape export const IS_ALLOWED_URI = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape export const IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i; export const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // This needs to be extensive thanks to Webkit/Blink's behavior "
],
names: [
"addToSet",
"set",
"array",
"l",
"length",
"toLowerCase",
"clone",
"object",
"newObject",
"property",
"Object",
"prototype",
"hasOwnProperty",
"call",
"createDOMPurify",
"window",
"getGlobal",
"DOMPurify",
"root",
"version",
"VERSION",
"removed",
"document",
"nodeType",
"isSupported",
"originalDocument",
"useDOMParser",
"useXHR",
"DocumentFragment",
"HTMLTemplateElement",
"Node",
"NodeFilter",
"NamedNodeMap",
"MozNamedAttrMap",
"Text",
"Comment",
"DOMParser",
"XMLHttpRequest",
"encodeURI",
"template",
"createElement",
"content",
"ownerDocument",
"implementation",
"createNodeIterator",
"getElementsByTagName",
"createDocumentFragment",
"importNode",
"hooks",
"createHTMLDocument",
"documentMode",
"MUSTACHE_EXPR",
"EXPRESSIONS",
"ERB_EXPR",
"DATA_ATTR",
"ARIA_ATTR",
"IS_SCRIPT_OR_DATA",
"ATTR_WHITESPACE",
"IS_ALLOWED_URI",
"ALLOWED_TAGS",
"DEFAULT_ALLOWED_TAGS",
"TAGS",
"ALLOWED_ATTR",
"DEFAULT_ALLOWED_ATTR",
"ATTRS",
"FORBID_TAGS",
"FORBID_ATTR",
"ALLOW_ARIA_ATTR",
"ALLOW_DATA_ATTR",
"ALLOW_UNKNOWN_PROTOCOLS",
"SAFE_FOR_JQUERY",
"SAFE_FOR_TEMPLATES",
"WHOLE_DOCUMENT",
"SET_CONFIG",
"FORCE_BODY",
"RETURN_DOM",
"RETURN_DOM_FRAGMENT",
"RETURN_DOM_IMPORT",
"SANITIZE_DOM",
"KEEP_CONTENT",
"USE_PROFILES",
"FORBID_CONTENTS",
"DATA_URI_TAGS",
"URI_SAFE_ATTRIBUTES",
"CONFIG",
"formElement",
"_parseConfig",
"cfg",
"ALLOWED_URI_REGEXP",
"html",
"svg",
"svgFilters",
"mathMl",
"ADD_TAGS",
"ADD_ATTR",
"ADD_URI_SAFE_ATTR",
"freeze",
"_forceRemove",
"node",
"push",
"element",
"parentNode",
"removeChild",
"err",
"outerHTML",
"_removeAttribute",
"name",
"getAttributeNode",
"removeAttribute",
"_initDocument",
"dirty",
"doc",
"body",
"xhr",
"responseType",
"open",
"send",
"response",
"parseFromString",
"documentElement",
"firstElementChild",
"querySelector",
"_createIterator",
"SHOW_ELEMENT",
"SHOW_COMMENT",
"SHOW_TEXT",
"FILTER_ACCEPT",
"_isClobbered",
"elm",
"nodeName",
"textContent",
"attributes",
"setAttribute",
"_isNode",
"obj",
"_executeHook",
"entryPoint",
"currentNode",
"data",
"forEach",
"_sanitizeElements",
"tagName",
"insertAdjacentHTML",
"innerHTML",
"test",
"cloneNode",
"replace",
"_sanitizeAttributes",
"attr",
"value",
"lcName",
"idAttr",
"hookEvent",
"trim",
"attrName",
"attrValue",
"keepAttr",
"id",
"Array",
"slice",
"apply",
"indexOf",
"pop",
"_sanitizeShadowDOM",
"fragment",
"shadowNode",
"shadowIterator",
"nextNode",
"sanitize",
"importedNode",
"oldNode",
"returnNode",
"toString",
"TypeError",
"_typeof",
"toStaticHTML",
"appendChild",
"firstChild",
"nodeIterator",
"setConfig",
"clearConfig",
"addHook",
"hookFunction",
"removeHook",
"removeHooks",
"removeAllHooks",
"text",
"xml"
],
mappings: "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,IAAxBsC,EAAMmD,QAAQ,YAC3CnD,SAIFD,GAAcC,WAIZnC,GAAa,KAAO,GAK3BD,OACWsC,EAAKiE,oBAIdC,EAAexD,GAAgBV,GAG7ByB,EAAcyC,EAAaX,YAEJ,IAAzB9B,EAAYlH,UAAkBkH,IAAgBiC,GAK9C9B,GAAkBH,KAKlBA,EAAYhG,mBAAmBb,MACd6G,EAAYhG,YAIbgG,KAEVA,MAIR9D,GAAY,IACVC,SACW9B,EAAuBjC,KAAKmG,EAAKtE,eAEvCsE,EAAKiE,cACCD,YAAYhE,EAAKiE,mBAGjBjE,SAGXnC,OAMW9B,EAAWlC,KAAKY,EAAkBkJ,GAAY,IAGtDA,SAGFnG,GAAiBwC,EAAKR,UAAYQ,EAAK+B,aAUtCoC,UAAY,SAAS5F,MAChBA,OACA,KASL6F,YAAc,cACb,SACI,KAULC,QAAU,SAAS7C,EAAY8C,GACX,mBAAjBA,MAGL9C,GAAcxF,EAAMwF,SACpBA,GAAYrC,KAAKmF,OAWfC,WAAa,SAAS/C,GAC1BxF,EAAMwF,MACFA,GAAY0B,SAWZsB,YAAc,SAAShD,GAC3BxF,EAAMwF,OACFA,UAUAiD,eAAiB,iBAIpBxK,ECr+BF,IAAMwE,GACX,IACA,OACA,UACA,UACA,OACA,UACA,QACA,QACA,IACA,MACA,MACA,MACA,QACA,aACA,OACA,KACA,SACA,SACA,UACA,SACA,OACA,OACA,MACA,WACA,UACA,OACA,WACA,KACA,YACA,MACA,UACA,MACA,MACA,MACA,KACA,KACA,UACA,KACA,WACA,aACA,SACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,UACA,OACA,WACA,QACA,MACA,OACA,KACA,WACA,SACA,SACA,IACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,OAIWC,GACX,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,QACA,SACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,QACA,OACA,SAGWC,GACX,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,cACA,eACA,WACA,qBACA,SACA,gBAGWC,GACX,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,eACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,UACA,QACA,UACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,cAGW8F,GAAQ,SC/NRjG,GACX,SACA,SACA,QACA,MACA,eACA,aACA,UACA,SACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,SACA,cACA,WACA,UACA,MACA,WACA,WACA,UACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,QACA,QACA,OACA,OACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,WACA,OACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,OACA,SACA,SACA,QACA,QACA,SAGWC,GACX,gBACA,aACA,aACA,qBACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,OACA,eACA,YACA,SACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,mBACA,mBACA,eACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,WACA,UACA,UACA,YACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,cAGWE,GACX,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,SAGW+F,GACX,aACA,SACA,cACA,YACA,eCzUWxI,EAAgB,4BAChBE,EAAW,wBACXC,EAAY,6BACZC,EAAY,iBACZG,EAAiB,wFACjBF,EAAoB,wBACpBC,EAAkB,0QHDzBzC,EAAY,iBAAyB,oBAAXD,OAAyB,KAAOA,eAm+BjDD"
}